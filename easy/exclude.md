# π“ Problem

- `T`μ—μ„ `U`μ— ν• λ‹Ήν•  μ μλ” νƒ€μ…μ„ μ μ™Έν•λ” λ‚΄μ¥ μ λ„¤λ¦­ `Exclude<T, U>`λ¥Ό μ΄λ¥Ό μ‚¬μ©ν•μ§€ μ•κ³  κµ¬ν„ν•μ„Έμ”.

## π” example

```ts
type Result = MyExclude<"a" | "b" | "c", "a">; // 'b' | 'c'
```

## π’­ Thinking

- union νƒ€μ…(T)μ—μ„ νΉμ • νƒ€μ…(U)μ„ μ μ™Έν• νƒ€μ… κµ¬ν„ν•κΈ°
- Tμ μ”μ†λ¥Ό κ°€μ Έμ¤κΈ° : κ°μ²΄μ—μ„λ” `[key keyof T]` μ΄λ°μ‹μΌλ΅ κ°€μ Έμ¬ μ μλ”λ° union νƒ€μ…μ—μ„λ” μ”μ† ν•λ‚μ”© μ–΄λ–»κ² κ°€μ Έμ΄?
- μλ„ : Tλ¥Ό λ°ν™ν•λ”λ° ν•΄λ‹Ή μ”μ†κ°€ Uμ— ν¬ν•¨λλ©΄ λ°ν™ μ•ν•κ³ , ν¬ν•¨ μ•λλ” κ²ƒλ§ λ°ν™
- ν•΄λ‹Ή μ”μ†λ¥Ό μ–΄λ–»κ² ν‘ν„ν•΄μ•Όν• κΉ?

## π Try

```ts
type MyExclude<T, U extends T> = keyof T extends keyof U ? never : keyof T;
```

## β… Answer

- λΉ„μ·ν•λ©΄μ„λ„ `extends`μ™€ `keyof` λ¥Ό μ λ€λ΅ μ΄ν•΄λ»ν• λ“―
- keyof T ν•λ©΄ μ”μ† ν•λ‚ν•λ‚λ¥Ό μλ―Έν•  μ¤„ μ•μ•λ”λ° κ·Έλƒ¥ μ§‘ν•©μ κ°λ…μΌλ΅ λ°›μ•„λ“¤μ΄λ” κ² λ§λ” λ“―
- `<U extends T>` ν•λ©΄ Uκ°€ Tλ¥Ό λ‹¤ κ°–κ³  μλ” κ² λλ²„λ¦¬λ”λ° μ΄μƒν•¨. μλ„λ” Tμ μ”μ†λ‹¤λ¥Ό ν‘ν„ν•κ³  μ‹¶μ—μ.
- keyof λ” `κ°μ²΄(object) νƒ€μ…` μ—μ„ μ“°λ” κ² μ μ ν• λ“―
- `T extends U` : Tκ°€ λ” ν° λ²”μ„λΌ μ–΄μƒ‰ν•  μ μμ§€λ§ T = 'a', U = 'a' μΈ κ²½μ°λ¥Ό trueλ΅ κ°€μ Έκ°€λ” μ΅°κ±΄μ‹
- μ‚Όν•­ μ—°μ‚°μλ¥Ό μ“°λ ¤λ©΄ μ΅°κ±΄μ‹μ„ μ¨μ•Όν•¨. `T extends U ? never` -> `Uκ°€ Tμ— ν¬ν•¨λλ” κ²½μ° νƒ€μ…μ— ν¬ν•¨ μ•ν•¨`

```ts
type MyExclude<T, U> = T extends U ? never : T;
```
